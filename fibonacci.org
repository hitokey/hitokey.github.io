#+Author: Pedro Fernandes
#+Date: <2021-03-09 ter>
#+Title: Simples programa de Fibonacci
#+SETUPFILE: ../org-html-themes/org/theme-bigblow.setup
#+LANGUAGE: pt_BR

* Introdução

Estou escrevendo este documento para testar o github blog, estão não espere nada demais nesta página.

** Fibonacci

Fibonacci é série numerica que descreve a seguinte senquencia *1,1,2,3,4,5,8,13...*, dessa maneira Leonardo Pisa descreve o crescimento pela seguiente fórmula: $F_n=F_{n-1}+F_{n-2}$, com a condição inicial $f(0)=0$ e $f(1)=1$, então:

Agora descrevemos em common lisp. Obs.: eu implementei no elisp em um emacs-windows. 

#+BEGIN_SRC elisp :export both :results html
(require 'cl)

(defun fib(n)
   (if (<= n 2) 1
         (+ (fib (- n 1)) (fib (- n 2)) )))

(format "<p>Fib(%d):= %d</p>" 5 (fib 8))
#+END_SRC

#+RESULTS:
#+BEGIN_EXPORT html
<p>Fib(5):= 21</p>
#+END_EXPORT

Eu quero verificar o tempo de execução da função fib que implementamos no elisp. 

#+BEGIN_SRC elisp :export both :results value code
(benchmark-run 1 (fib 40))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC elisp
(36.699033 0 0.0)
#+END_SRC

É demorou 36 segundos para executar o fibonacci 40, na lista o primeiro é o tempo real de execução, segundo o número fde coletas de lixos e finalizando o tempo gasto pelo coletor de lixo, agora executar por meio de uma complexão binária.

#+BEGIN_SRC elisp :export both :results code
(benchmark-run-compiled 1 (fib 40))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC elisp
(36.616515 0 0.0)
#+END_SRC

Não mudou particamente nada, principalmente se adicionamos o erro experimental. 

Podemos mudar um pouco a nossa função fibonacci, porque na nossa função como usamos da recursão, o sistema deverá ultizar bastante a pinha para amazenar e depois recalcular o valor de resposta. Então irei implentar utilizando a recursão, mas adicionarei um acumulador.

#+BEGIN_SRC elisp :export both :results html
(defun fib-acc(n prev acc)
  (if (<= n 0) acc 
     (fib-acc (- n 1) acc (+ prev acc))))

(defun fib(n)
  (if (<= n 1) n
    (fib-acc n 1 0)))

(funcall (lambda (n) (format "<p>Fib(%d): %d</p>" n (fib n))) 40)
#+END_SRC

#+RESULTS:
#+BEGIN_EXPORT html
<p>Fib(40): 102334155</p>
#+END_EXPORT

#+BEGIN_SRC elisp :export both :results code
(benchmark-run-compiled 1 (fib 40))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC elisp
(1.4e-05 0 0.0)
#+END_SRC

Notamos que o tempos foi de 1.5x10^5, particamente zero, estão é bom trabalhamos com acumulador.
