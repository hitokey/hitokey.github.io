<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt_BR" xml:lang="pt_BR">
<head>
<!-- 2022-04-07 Thu 13:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clean in LISP from Web System</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Pedro Fernandes" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Clean in LISP from Web System</h1>
<div id="table-of-contents">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6a018f2">1. Sistema Web.</a>
<ul>
<li><a href="#org95856d8">1.1. Clean</a></li>
<li><a href="#orgd2d9b66">1.2. Instalação</a></li>
<li><a href="#orgd7ef15b">1.3. Configuração.</a></li>
<li><a href="#orgbd164a5">1.4. Simples programa em Clean para Web.</a></li>
<li><a href="#org61338ba">1.5. Mas Falaremos um pouco de LISP.</a></li>
<li><a href="#org63d230e">1.6. Lisp GGI.</a></li>
<li><a href="#org5012535">1.7. Lisp control Clean por Object System Interface</a></li>
<li><a href="#orgb5fb76e">1.8. Lisp and Clean Foreign Function Interface</a>
<ul>
<li><a href="#orgb4c517d">1.8.1. Clean Foreign</a></li>
</ul>
</li>
<li><a href="#org29e062c">1.9. Lisp Hunchentoot Básico</a></li>
<li><a href="#orgbb09f62">1.10. GET Simples - Hello World;</a></li>
<li><a href="#org6df2b2a">1.11. Lisp Hunchentoot Avancado</a>
<ul>
<li><a href="#orgd6c3597">1.11.1. GET/POST/PUT Request</a></li>
<li><a href="#org0fa7f56">1.11.2. HTTP HEADERS</a></li>
<li><a href="#org85fb5dd">1.11.3. IO Json</a></li>
<li><a href="#orgece74d1">1.11.4. IO Binary Stream</a></li>
<li><a href="#org6177bb2">1.11.5. Authorization</a></li>
<li><a href="#org43d74d8">1.11.6. CGI Script</a></li>
</ul>
</li>
<li><a href="#org7b0328a">1.12. Extra: HTML e JavaScript</a></li>
</ul>
</li>
<li><a href="#org63ce732">2. Docker</a></li>
<li><a href="#org2298533">3. Instalação</a></li>
<li><a href="#org8281eff">4. Cloun Run (Google Cloud)</a></li>
<li><a href="#orge21f162">5. Home</a></li>
<li><a href="#orgdb5786c">6. imagens/cgi<sub>lisp.png</sub></a></li>
</ul>
</div>
</div>


<div id="outline-container-org6a018f2" class="outline-2">
<h2 id="org6a018f2"><span class="section-number-2">1</span> Sistema Web.</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org95856d8" class="outline-3">
<h3 id="org95856d8"><span class="section-number-3">1.1</span> Clean</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Clean e Lisp são linguagens funcionais.
</p>
</div>
</div>

<div id="outline-container-orgd2d9b66" class="outline-3">
<h3 id="orgd2d9b66"><span class="section-number-3">1.2</span> Instalação</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A instalação é bastante simples, por iremos já utiliza-se de uma versão já pré-compilada. Sendo assim não será preciso configuramos muita coisa. Além disso como queremos criar um páginas Web para servidores linux, iremos baixar a versão clean-bundle-complete-linux-x64-latest.tgz. Você consiguirá acessando a seguinte página do <a href="https://wiki.clean.cs.ru.nl/Download_Clean">Clean</a>.
</p>
</div>
</div>

<div id="outline-container-orgd7ef15b" class="outline-3">
<h3 id="orgd7ef15b"><span class="section-number-3">1.3</span> Configuração.</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Depois de baixar o arquivo, pelo terminal fazemos as seguintes configuração.
</p>

<pre class="example">
# mv Download/clean-bundle-complete-linux-x64-latest.tgz ~/
# tar xvf clean-bundle-complete-linux-x64-latest.tgz .
# mv clean-bundle-complete clean/
</pre>

<p>
Com o directório clean criado, vamos então configura no arquivo ~/.bashrc as seguintes variáveis.
</p>

<pre class="example">
# echo "export CLEAN_HOME=~/clean &gt;&gt; ~/.bashrc
# echo "export PATH=$PATH:$CLEAN_HOME/bin &gt;&gt; ~/.bashrc
</pre>
</div>
</div>

<div id="outline-container-orgbd164a5" class="outline-3">
<h3 id="orgbd164a5"><span class="section-number-3">1.4</span> Simples programa em Clean para Web.</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Neste casso, o programa que iremos aborda são para web servering, com pro exemplo o apache, ningx etc. Servidores que gerencia todas as conexão e requisições necessárias para uma comunicação web. Tais programas chamamos de Common Gateway Inferface (CGI). Recomendo o excelente livro: <a href="https://docstore.mik.ua/orelly/linux/cgi/index.htm">CGI Programming with perl</a>, aonde ele aborta tais methodo. Então, vamos ao program.
</p>

<pre class="example">
module printenv;

import StdEnv, ArgEnv;

Start w
  # (cgi, w) = stdio w;
  # ctype= "Content-Type:text/html;charset=utf-8";
  # cgi= fwrites ctype cgi;
  # cgi= fwrites({toChar 13, toChar 10}+++"\n") cgi;
  # cgi= fwrites "&lt;html&gt;\n" cgi;
  # cgi= fwrites "&lt;body&gt;\n" cgi;
  # cgi= fwrites "&lt;h1&gt;Hello: " cgi;
  # xx= ans (getEnvironmentVariable "QUERY_STRING");
  # cgi= fwrites (xx+++"&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n") cgi;
  = cgi;
where {
   ans EnvironmentVariableUndefined="none";
   ans (EnvironmentVariable v)= v; }
</pre>

<p>
No Clean precisamos antes de rodar nosso program complilar nosso código, iremos usar um parte importe dos arquivos já baixados, que é o ArgEnv, o mesmo deverá está no directorio lib/ dentro do directorio do clean baixado. Então, tente vê se caso receba um erro, pode ser que esteja faltando esta library. Vejamos, como complilamos este código.
</p>

<div class="org-src-container">
<pre class="src src-sh">clm -b -nt -nr hello-web -O hello.cgi
./hello.cgi
</pre>
</div>

<p>
Tal program retorna quando rodado no localmente.
</p>

Content-Type:text/html;charset=utf-8

<html>
<body>
<h1>Hello: none</h1>
</body>
</html>

<p>
Discutiremos um pouco sobre o programa. O codigo é bastante simples, basicamente ele concatena string no formato response html, com um variável do servidor que é a \(QUERY\_STRING\), tal variável amazena um parte do URL. Nesta parte normalmente poderá ser passado alguma key e valor, por exemplo, vejamos a URL:
</p>

<p>
Recomendo que leia o <a href="https://docstore.mik.ua/orelly/linux/cgi/ch03_02.htm">Enviroment Variables</a> e <a href="https://docstore.mik.ua/orelly/linux/cgi/ch02_01.htm">HTTP</a>.
</p>
</div>
</div>

<div id="outline-container-org61338ba" class="outline-3">
<h3 id="org61338ba"><span class="section-number-3">1.5</span> Mas Falaremos um pouco de LISP.</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Estou abortando o lisp nesta documento porque objetivo maior é interligamos as linguagem LISP com a linguagem CLEAN. Aonde deixamos que o Lisp gerencie o Servidor e usamos programas já escrito nele CLEAN, nem a necessidade de reescremos o mesmo.
</p>

<p>
Obs.: Esta ideia é apenas para um treinamento e educacional, não haverá um comparação desempenho ou uma tentativa de explicação do porque fazemos isto e não optamos por simples programa no flask + gunicorn do python, ou outra linguagem popular do momento em que estiver lendo este documento.
</p>
</div>
</div>

<div id="outline-container-org63d230e" class="outline-3">
<h3 id="org63d230e"><span class="section-number-3">1.6</span> Lisp GGI.</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Podemos também fazer um aplicação GUI com o lisp, não é nosso objetivo, mas podemos observar.
</p>

<pre class="example">
#!/usr/local/bin/sbcl --script

(format t "Content-type: text/html~%~%")

(format t
" &lt;html&gt;
   &lt;body&gt;
    &lt;h1&gt;Hello, ~a&lt;/h1&gt;
   &lt;/body&gt;
  &lt;/html&gt;"
(sb-ext:posix-getenv "QUERY_STRING")
)
</pre>

<p>
Neste caso, vale observar que diferente do clean está versão do código e impletado em tempo de execução, ou seja, está no formato script.
</p>
</div>
</div>

<div id="outline-container-org5012535" class="outline-3">
<h3 id="org5012535"><span class="section-number-3">1.7</span> Lisp control Clean por Object System Interface</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Primeira, uma alternativa para controle do clean programa é usamos o controle de sistema apartir do SO(Sistema Operacional), dessa maneira codificado.
</p>

<pre class="example">
(sb-ext:run-program "./hello.cgi" nil :output *standard-output*)
</pre>

<p>
Temos o resultado:
</p>
<pre class="example" id="orgef4bf63">
Hello,World!
#&lt;SB-IMPL::PROCESS :EXITED 0&gt;
</pre>

<p>
Usamos a função run-program possui um variação dependendo do common lisp que esteja executado, no sbcl o package sb-ext, já por exemplo ecl, o run-program está no package <b>ext</b> apenas, neste caso a estrutura é a mesma, em todo caso sempre der uma olhada no manual do seu imterpetador, mas não se preocupe muito, existem esta diferença mas normalmente elas são voltada mais para pacotes extras de cada imterpetador, mas o restante todos os interpetador que seguem a padrão ANSI, contando que estamos falando se Common Lisp, não de Lisp. Que são o lisp do sbcl e ecl. Vejamos o OSI do ecl.
</p>

<pre class="example">
(ext:run-program "./hello" nil :output :stream)
</pre>

<pre class="example" id="org9c6ece7">
Hello,World!

#&lt;output stream "FD-STREAM" 0x7fffc8ba2e60&gt;
0
#S(EXT:EXTERNAL-PROCESS :PID NIL :INPUT #&lt;output stream "FD-STREAM" 0x7fffc8ba2e60&gt; :OUTPUT NIL :ERROR-STREAM #&lt;input stream "FD-STREAM" 0x7fffc8ba2dc0&gt; :%STATUS :EXITED :%CODE 0 :%LOCK #&lt;lock (nonrecursive) 0x7fffc8927300&gt; :%PIPE #&lt;process 0x7fffc88fcf80&gt;)
</pre>

<p>
Vemos que o retorno no ecl, são três valores, podemos que podemos processá-los como quisermos, exemplo:
</p>

<pre class="example">
(multiple-value-bind (x y z) (ext:run-program "./hello" nil :output t) z))
</pre>

<p>
Neste casso apenas pegamos o z, que o processo.
</p>
<pre class="example" id="org93a6c11">
#S(EXT:EXTERNAL-PROCESS :PID NIL :INPUT #&lt;output stream "FD-STREAM" 0x7fffea8ac8c0&gt; :OUTPUT NIL :ERROR-STREAM #&lt;input stream "FD-STREAM" 0x7fffea8ac820&gt; :%STATUS :EXITED :%CODE 0 :%LOCK #&lt;lock (nonrecursive) 0x7fffea3bdbd0&gt; :%PIPE #&lt;process 0x7fffea464880&gt;)
</pre>

<p>
De qualquer forma o common lisp permite que controle qual será a função que iremos chamar verificado a versão do interpetador, por exemplo:
</p>

<pre class="example">
(defun my-run (program argv)
     (declare (type string program))
     (declare (type list argv))
   (let ((process 
	  (or #+sbcl (sb-ext:process-output
			(sb-ext:run-program program argv :output :stream))
	      #+ecl (ext:run-program program argv :output :stream)) ))
     (loop for line = (read-line process nil nil)
	 while line do (format t "~a" line)) )) 


(my-run "./hello" nil)
</pre>

<pre class="example" id="orga1b62ea">
Hello,World!
NIL
</pre>

<p>
Então, com este processo podemos por exemplo controlar produtor de audio, por exemplo, vejamos.
</p>

<pre class="example">
(sb-ext:run-program "play" '("/home/pedro/sound/sound.mp3")
			    :output nil :wait nil)
</pre>

<p>
<b>Obs.</b>: é necessario ter o sox instalado, instalar: sudo apt install sox
</p>

<pre class="example">
(sb-ext:run-program "cmd.exe" '("/C" "start" "D:/Sound/sound.mp3")
				:search t :windows :hide)
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listagem 5: </span>Linux in Windows (WSL)</label><pre class="src src-lisp">(sb-ext:run-program "cmd.exe" '("/C" "start" "D:/Sound/sound.mp3")
			       :search t )                   
</pre>
</div>

<p>
Vemos que podemos controlar varios process entre outro com o lisp, então uma possibilidade é controla o programa compilado em clean, afinal o programa estará em formato <b>elf</b>, vamos então testa-lo, usamos o programa my-run, escrito anteriormente.
</p>

<pre class="example">
(my-run "./hello.cgi" nil)
</pre>

<p>
Vemos que conseguimos reproduzir no lisp a resposta do clean, vejamos o resultado abaixo.
</p>
<pre class="example" id="orgcb987c4">
&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello: none&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
NIL
</pre>
</div>
</div>

<div id="outline-container-orgb5fb76e" class="outline-3">
<h3 id="orgb5fb76e"><span class="section-number-3">1.8</span> Lisp and Clean Foreign Function Interface</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Vamos começa usando function do clean no lisp. Então quando olhamos no manual do cleam, vejamos como export seu código do clean para serem usado em outra linguagem, que pode ser n-linguagem, inclusive o python, mas iremos utilizar a código clean no Lisp.
</p>
</div>

<div id="outline-container-orgb4c517d" class="outline-4">
<h4 id="orgb4c517d"><span class="section-number-4">1.8.1</span> Clean Foreign</h4>
</div>
</div>

<div id="outline-container-org29e062c" class="outline-3">
<h3 id="org29e062c"><span class="section-number-3">1.9</span> Lisp Hunchentoot Básico</h3>
<div class="outline-text-3" id="text-1-9">
<p>
O sistema hunchentoot é um interface de rede com ferramentas para construções de sites dinamicos. Ele funciona com um servidor web independente, ele é capaz de conexão HTTP/1.1 chunking, conexão persistentes e SSL. Além disso ele fornece diversos recurso de manipulação automatica de sessão, registro etc. Ou seja, ele tem além dessa funções muitas outras, mas caso queira saber de todas visite o site do <a href="http://edicl.github.io/hunchentoot/">hunchentoot</a>.
</p>

<p>
Então começamos o que interessa, construir uma aplicação web-server em lisp. Começamos com algo simples, um helloword
</p>

<pre class="example">
(ql:quickload :hunchentoot)
</pre>

<pre class="example" id="org51ef3a4">

(ql:quickload :hunchentoot)
To load "hunchentoot":
  Load 1 ASDF system:
    hunchentoot
; Loading "hunchentoot"

(:HUNCHENTOOT)
</pre>

<p>
Como iremos precisar do hunchentoot, podemos usar o quicklisp para carrega-lo, caso seja a primeira vez fazendo este commando, o sistema irá apresentar mais infomações com um semelhante a isto:
</p>

<pre class="example" id="org8293e43">
; Loading "hunchentoot"
[package chunga]..................................
[package cl-base64]...............................
[package cl-fad]..................................
[package path]....................................
[package cl+ssl/config]...........................
[package usocket].................................
[package cl+ssl]..................................
[package md5].....................................
[package rfc2388].................................
[package trivial-backtrace].......................
[package url-rewrite].............................
[package hunchentoot]..........................
(:HUNCHENTOOT)
</pre>

<p>
Como hunchentoot em vale ressaltar, que qualquer infomação dentro desse pacote terãom o sufixo hunchentoot:, caso queira evitar isto basta usar <b>in-package</b>, mais informaçãoes <a href="https://www.tutorialspoint.com/lisp/lisp_packages.htm">link</a>.
</p>

<p>
Então começamos iniciando um servidor http simples, com uma função dinamica que pegar a query\<sub>string</sub> é diz um Hello, caso não term a query\<sub>string</sub>, diz hello, world.
</p>

<pre class="example">
(hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242))
</pre>

<pre class="example" id="orgf0cfd88">
#&lt;HUNCHENTOOT:EASY-ACCEPTOR (host *, port 4242)&gt;
</pre>

<p>
Como este commando iniciamos o sevidor na porta 4242 no localhost(que é ip do local do nosso computador), se você iniciou, acesse por <a href="http://localhost:4242">http://localhost:4242</a>, esta porta podemos escolher, mas devemos ficar atento com as portas já utilizados pelo SO e outra aplicações Web. O numero da porta possui um intervalos de (0 à \(2^{10}\)). Você pode vê as opções <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">aqui</a>.
</p>


<p>
Quando acessar o link pelo browser veremos isto no browser:
</p>

<p>
<a href="./imagens/localhost.png">./imagens/localhost.png</a>
</p>

<p>
E isso no terminal:
</p>

<pre class="example" id="org8ab1935">
127.0.0.1 - [2022-03-31 02:04:52] "GET / HTTP/1.1" 200 393 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36"
</pre>
</div>
</div>

<div id="outline-container-orgbb09f62" class="outline-3">
<h3 id="orgbb09f62"><span class="section-number-3">1.10</span> GET Simples - Hello World;</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Então programos o hello world pelo método GET, então escrevemos:
</p>

<pre class="example">
(ql:quickload :hunchentoot)

(defparameter *web* (make-instance 'hunchentoot:easy-acceptor
				    :port 4242))

(hunchentoot:define-easy-handler (hello :uri "/hello") (nome)
  (setf (hunchentoot:content-type*) "text/plain")
  (format nil "Hello, ~a!" (if (null nome) "World" nome)))

(hunchentoot:start *web*)

</pre>

<p>
Podemos visualizar no browser o resultado no link: <a href="http://localhost:4242/hello?nome=pedro">http://localhost:4242/hello?nome=pedro</a>, com meu nome.
</p>


<div id="org773dfa2" class="figure">
<p><img src="./imagens/name_hello.png" alt="name_hello.png" />
</p>
</div>


<p>
Sem nome in <a href="https://localhost:4242/hello">https://localhost:4242/hello</a>
</p>


<div id="org11590db" class="figure">
<p><img src="./imagens/world_hello.png" alt="world_hello.png" />
</p>
</div>


<p>
Para desativar o servidor basta digitar:
</p>

<pre class="example">
(hunchentoot:stop *web*)
</pre>
</div>
</div>

<div id="outline-container-org6df2b2a" class="outline-3">
<h3 id="org6df2b2a"><span class="section-number-3">1.11</span> Lisp Hunchentoot Avancado</h3>
<div class="outline-text-3" id="text-1-11">
<p>
Vamos fazer alguma applicação mais complexa, que são o seguintes pontos:
</p>

<ul class="org-ul">
<li>GET/POST REQUEST</li>
<li>HTTP HEADERS</li>
<li>Input/Output JSON</li>
<li>Input/Output RAW BYTES INFOMATION</li>
<li>Authentification</li>
<li>CGI script</li>
</ul>
</div>

<div id="outline-container-orgd6c3597" class="outline-4">
<h4 id="orgd6c3597"><span class="section-number-4">1.11.1</span> GET/POST/PUT Request</h4>
<div class="outline-text-4" id="text-1-11-1">
</div>
<ol class="org-ol">
<li><a id="orga14615f"></a>GET Request<br />
<div class="outline-text-5" id="text-1-11-1-1">
<p>
O método get e post é exencial para a comunicação HTTP, como vimos no <b>GET Simples - Hello World</b>, usamos o método GET, quando manipulamos a QUERY<sub>STRING</sub>, mas vejamos novamente outra aplicação utilizando o método Query.
</p>

<div class="org-src-container">
<pre class="src src-lisp">;; file: client_fib.lisp
(ql:quickload :hunchentoot)


(defparameter *web* (make-instance 'hunchentoot:easy-acceptor
				       :port 4242))


(defun fib(n &amp;optional (prev 1) (acc 0))
    (cond ((&gt; n 50) "limite break, because we limit cost")
	  ((&lt;= n 0) acc)
	  (t (fib (- n 1) acc (+ prev acc)) )))

(defun client-name(name)
  (if (null name) "Hello, Cliente"
      (format nil "Hello, ~a!" name)))

(hunchentoot:define-easy-handler (hello :uri "/fib") (number name)
  (setf (hunchentoot:content-type*) "text/html")
  (let ((v (fib (parse-integer number))) (c (client-name name)))
    (format nil "&lt;html&gt;&lt;body&gt;&lt;h1&gt;~a&lt;\h1&gt;&lt;p&gt;Fib: ~a&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;" c v)) )


(hunchentoot:start *web*)

;; user: sbcl --load client_fib.lisp


</pre>
</div>

<p>
Agora podemos acessar a página pela url =&gt; <a href="http://localhost:4242/fib?number=40&amp;name=pedro">http://localhost:4242/fib?number=40&amp;name=pedro</a>. A QUERY\<sub>STRING</sub> dessa url é "?number=40&amp;name=pedro", os paramentos paramentos da função <b>define-easy-handler</b> do hunchentoot são <b>number</b> e <b>name</b>, tais valores são atribuitos pelo conteudo da query number e name respecitivamente. Sendo assim, pegamos tais valores é enviamos a funções <b>fib</b> e *client-name, que nós retorna o valores de resposta. Obs.: para função fib, primeiramente convertemos o valores em inteiro.
</p>

<p>
Neste caso a propria função <b>define-easy-handler</b> separa o conteúdo da query string pelas key como os mesmo nome dos symbols de entrada, conforme vemos o number (symbol) e na url <b>number=</b> (key=), mas caso queria pegar o contéudo da query<sub>string</sub> por completo podemos fazer o seguinte.
</p>


<pre class="example">
(ql:quickload :hunchentoot)


(hunchentoot:define-easy-handler (get-query :uri "/") ()
  (let* ((req hunchentoot:*request*)
	 (qs (hunchentoot:query-string* req)))

   (format nil "Query_STRING: ~a" qs)))


</pre>


<p>
Por exemplo, testamos o seguinte url =&gt; <a href="http://localhost:4242/?pedro=pedro&amp;gabrage=%C3%A7ajfdkam">http://localhost:4242/?pedro=pedro&amp;gabrage=%C3%A7ajfdkam</a>, vejamos o resultado.
</p>

<p>
<a href="./imagens/query_string.png">./imagens/query<sub>string.png</sub></a>
</p>

<p>
Dessa forma, como a Query\<sub>String</sub> é um string podemos manipulamos com queremos. Mas vejamos um pouco de teória, o que acontece aqui é que o hunchentoot gerencia todos os request recebedo nos entypoint, de modo que toda vez que ele recebe um request é amazena em uma variável global chamada <b>request</b> todos os paramento passado para o programa em lisp pelo o usuário solicitador (ou seja, o cliente), sendo assim podemos verificar varias coisas neste requeste, uma delas é a QUERY<sub>STRING</sub>. Outra maneira de mamipulamos a Query\<sub>STRING</sub> por variável ambiente. Como é um web-server ele também amazena os valores da QUERY<sub>STRING</sub> na variável com o mesmo nome. Importate é tomamos cuidado com está variável para outro valores vazarem para outra solicitações, mas de qualquer forma abortaremos está questão no subtema <b>CGI</b>, contéudo petencente a este mesmo manual.
</p>
</div>
</li>

<li><a id="orgb555ecb"></a>POST Request<br />
<div class="outline-text-5" id="text-1-11-1-2">
<p>
O método POST request é muito importante na comunição TCP/IP do HTTP/HTTPS, sendo assim iremos demostra algumas programas utilizamos o post como método, mas tarde nos aprofuntaremos, na passagem de json e outro tipos de dados pelo método post. Vejemos então um aplicação básica.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(hunchentoot:define-easy-handler (hello-post :uri "/hellopost" :default-request-type :post) (name)
  (setf (hunchentoot:content-type*) "text/html")
  (format nil "Hello, ~a!" name))

</pre>
</div>

<p>
Neste entypoint apenas aceita post, de modo que se queremos acessar valores que são possado via post, então para testa podemos utiliza-se o html;
</p>

<p>
Também queria pode utiliza-se de ferramento do tipo <a href="https://www.postman.com/">Postman</a>. Também podemos pegar o conteudo do post completo sem o sistema força o parser nas key.
</p>


<div class="org-src-container">
<pre class="src src-lisp">
(hunchentoot:define-easy-handler (get-post :uri "/postall" :default-request-type :post) ()
 (setf (hunchentoot:content-type*) "text/pain")
 (let ((ps (hunchentoot:post-parameters* hunchentoot:*request*)))
    (format nil "POST: ~a" ps)) )

</pre>
</div>

<p>
Novamente podemos testar com o html abaixo:
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org0fa7f56" class="outline-4">
<h4 id="org0fa7f56"><span class="section-number-4">1.11.2</span> HTTP HEADERS</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
Quando trabalhamos com protocolo de redes, e principalmente na comunica TCP/IP, tevemos nos atentar no cabeçario, ou header, então vamos aborta um pouco de como definimos este paramento no hunchentoot. O importante é sempre seguimos os procotolo da do W3C, que estabele-se diretizem de como deveram ser a comunicação da rede <a href="https://www.w3.org/TR/trace-context/#trace-context-http-headers-format">WC3 HTTP header</a>.
</p>

<p>
De qualquer maneira vejamos como podemos definir nosso headers. Vejamos o exemplo para uma comunicação que deverá receber um json.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(hunchentoot:define-easy-handler (infos-json :uri "/system/menu") ()
  (setf (hunchentoot:content-type*) "application/json; charset=utf-8")
  (setf (hunchentoot:header-out "Access-Control-Allow-Origin") "*")
  (setf (hunchentoot:header-out "Content-Type") "application/json")
  (setf (hunchentoot:header-out "Access-Control-Allow-Headers")
	"Content-Type, authorization")
  (multiple-value-bind (username password) (hunchentoot:authorization)
    (format nil "~a ~a"  username password) ))
</pre>
</div>


<p>
Neste entypoint definimos que o conteudo que iremos retorna será um "application/json", definido o <b>Content-type</b>, até aqui não definimos o header. Mas quando declaremos <b>(setf (hunchentoot:header-out "Access-Control-Allow-Origin") "</b>")*, dessemos que o campo "Access-Control-Allow-Origin", com \*, dissemos que o conteudo da solicitação será sem crendeciais. Na linha logo  abaixo, definimos o tipo de dado que deverá esta na entrada, deverá <b>application/json</b>, por fim devimos por ultimo que o controle de acesso ao headers deverá passar por authenticação.
</p>

<p>
No exemplo usamos este tipos de cabeçario, mas você pode configurar o que quiser, basta manter o padrão apresentado, <b>(setf (hunchentoot:header-out "KEY") "NEW-VALUE")</b>.
</p>
</div>
</div>

<div id="outline-container-org85fb5dd" class="outline-4">
<h4 id="org85fb5dd"><span class="section-number-4">1.11.3</span> IO Json</h4>
<div class="outline-text-4" id="text-1-11-3">
<p>
Uma maneira bastante util de compartinha dados na rede é usamos o formato json, principalmente entre servidores ou API's, existem também a possibilidade do XML, mas o json é uma maneira bem mais simples de trabalhar, então vejamos com trabalharemos com json no hunchentoot. Nesta aplicação iremos receber um json é retorna um json, no caso será o mesmo json de entrada, como exemplo, mas o json de saida poderá ser qualquer outro, só para fins de demostração iremos utilizar o mesmo json, mas deverá funcionar com qualquer outro que a aplicação retorna. Então vejamos:
</p>


<div class="org-src-container">
<pre class="src src-lisp">
(ql:quickload :cl-json)


(hunchentoot:define-easy-handler (json-io :uri "/json") ()
  (setf (hunchentoot:content-type*) "application/json; charset=utf-8")
  (setf (hunchentoot:header-out "Context-Type") "application/json; charset=utf-8")
  (let* ((raw-data (hunchentoot:raw-post-data :force-text t))
	 (js (with-input-from-string (s raw-data) (json:decode-json s))) )
    (format nil "~a" (json:encode-json-to-string js))))
</pre>
</div>

<p>
O importante aqui é que configuramos um ponto de entrada que entrar json, mas quando iremos ler no hunchentoot forçamos para ler como text, existem a possibilidade de ferem binary também,
ao obter todos os corpo do request, usamos outra library, <b>cl-json</b>, uma library que manipula json, sendo assim com a mesma decoficamos a string para json, outra coisa antes de retorna o resultado codificamos nosso objeto json para string.
</p>

<p>
Para testar este entypoint, precisamos fazer um request passando um json, novamente podemos utiliza aplicativos com <b>post-man</b>, mas aproveitamos sbcl, fazemos então com o sbcl.
</p>

<div class="org-src-container">
<pre class="src src-lisp">  (ql:quickload :drakma)

  (defun post-request(url &amp;optional string-json) 
    (multiple-value-bind (stream status-code)
	(drakma:http-request url :content string-json
			     :content-type "application/json; charset=utf-8" :want-stream t)
    (let ((r nil))
      (when stream
	(loop for line = (read-line stream nil)
	   while line do (push line r))
      (close stream))
    (values status-code (format nil "~{~a~^~% ~}" r))) ))


;; run:  (post-request "http://192.168.100.28:4242/json" "{\"name\": \"pedro\"}")

</pre>
</div>

<p>
Esta função recebe url e um paramento opcional que deverá ser um string com formato json, que responderá um inteiro, corresponde ao código de status da comunição http e o body da responda em formato string. Como será um json, será um string no formato json.
</p>
</div>
</div>

<div id="outline-container-orgece74d1" class="outline-4">
<h4 id="orgece74d1"><span class="section-number-4">1.11.4</span> IO Binary Stream</h4>
<div class="outline-text-4" id="text-1-11-4">
<p>
Como estaremos trabalhando com dados binário, devemos trabalhar o que estavamos recebendo, mas vamos supor que nossa aplicação está atras de proxy ou que o request para por um authentificação antes mesmo de receber o streams (transmissão).
</p>


<pre class="example">
#+begin_src lisp

  (ql:quickload :cl-json)

  (hunchentoot:define-easy-handler (json-io :uri "/json") ()
    (setf (hunchentoot:content-type*) "application/json; charset=utf-8")
    (setf (hunchentoot:header-out "Context-Type") "application/json; charset=utf-8")
    (hunchentoot:raw-post-data :force-binary t))

</pre>

<p>
#+end<sub>src</sub>
</p>
</div>
</div>

<div id="outline-container-org6177bb2" class="outline-4">
<h4 id="org6177bb2"><span class="section-number-4">1.11.5</span> Authorization</h4>
<div class="outline-text-4" id="text-1-11-5">
<p>
Criamos um sistema de authentificação, abortando o básico o método <b>Basic Auth</b>, também falaremos um pouco de como acessar o cabeçario (ou header) de 'AUTHORIZATION', como isso fazemos a athenticação que queremos.
</p>


<ul class="org-ul">
<li>O Basic Auth é uma authentificação simples que passa um string no formato base64 com usuário e senha separado por ; (ponto e vigula). Como é uma authentificação mais simples pode utiliza-se de uma função já existente no hunchentoot, que já nos passa o o usuário e senha, então vejamos:</li>
</ul>

<pre class="example">

(hunchentoot:define-easy-handler (authz :uri "/auth") ()
  (setf (hunchentoot:content-type*) "text/plain")
  (setf (hunchentoot:header-out "Access-Control-Allow-Origin") "*")
  (setf (hunchentoot:header-out "Content-Type") "text/html;application/json")
  (setf (hunchentoot:header-out "Access-Control-Allow-Headers")	
	"Content-Type, authorization")
  (setf (hunchentoot:return-code*) hunchentoot:+http-bad-request+)
  (multiple-value-bind (username password) (hunchentoot:authorization)
    (format nil "User: ~A ; Password: ~A" username password)))

</pre>

<p>
Caso seja necessário usamos outro tipos de authentificação, podemos obter acesso no contéudo do cabeçario 'AUTHORIZATION', vejamos então o cabeçario:
</p>

<pre class="example">

(hunchentoot:define-easy-handler (authz :uri "/auth") ()
  (setf (hunchentoot:content-type*) "text/plain")
  (setf (hunchentoot:header-out "Access-Control-Allow-Origin") "*")
  (setf (hunchentoot:header-out "Content-Type") "text/html;application/json")
  (setf (hunchentoot:header-out "Access-Control-Allow-Headers")	
	"Content-Type, authorization")
  (format nil "~a" (hunchentoot:header-in* "Authorization"))

</pre>
</div>
</div>

<div id="outline-container-org43d74d8" class="outline-4">
<h4 id="org43d74d8"><span class="section-number-4">1.11.6</span> CGI Script</h4>
<div class="outline-text-4" id="text-1-11-6">
<p>
Antes de começamos devemos esclarer a sigla CGI, está sigla ao contrario do CGI usados em filmes da marvel ou em qualquer ciname, que possui um nome <b>Computer Generated Imagery</b>, o nosso CGI significa na verdade (Common Gateway Interface), que é uma interface que permite que o servidor execute código externo a ele, ou seja, execução de código que não faze parte do código padrão do servidor. Então vejamos como habilitamos este recurso no hunchentoot, implemetamos o seguinte trecho.
</p>

<pre class="example">
(ql:quickload :hunchentoot-cgi)
(ql:quickload :chunga)

(setf chunga:*accept-bogus-eols* t)
(pushnew (hunchentoot-cgi:create-cgi-dispatcher-and-handler
	  "/cgi/" ;; url-enderenco
	  "/mnt/d/Works/cgi/" ;; base locatization cgi program
	 ) hunchentoot:*dispatch-table* :test #'equal)

</pre>

<p>
Então testamos aquele programa em clean escrevemos antes, o hello.icl, aonde complitamos o mesmo para hello.cgi, vejamos abaixo o resultado:
</p>

<p>
<a href="./imagens/cgi_clean.png">/imagens/cgi<sub>clean.png</sub></a>
</p>

<p>
Podemos rodar programas semelhante em qualquer linguagem, por exemplo, em python:
</p>

<div class="org-src-container">
<pre class="src src-python">#!/usr/bin/python3.8

import os

def hello_cgi(text):
  name = text if text is not None else "World"
  return "&lt;p&gt;Hello, {}!&lt;/p&gt;".format(name)

print("Content-type: text/html\n\n")
print("&lt;html&gt;&lt;body&gt;&lt;h1&gt;From Python&lt;/h1&gt;")
print(hello_cgi(os.environ['QUERY_STRING']))
print("&lt;/body&gt;&lt;/html&gt;")
</pre>
</div>

<p>
<a href="./imagens/cgi_python.png">./imagens/cgi<sub>python.png</sub></a>
</p>

<p>
Também podemos fazer isto com o lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp">#!/usr/local/bin/sbcl --script

(format t "Content-type: text/html~%~%")

(format t
" &lt;html&gt;
   &lt;body&gt;
    &lt;h1&gt;Hello, ~a&lt;/h1&gt;
   &lt;/body&gt;
  &lt;/html&gt;"
 (let ((qs (sb-ext:posix-getenv "QUERY_STRING")))
       (if (zerop (length qs)) "World" qs))
)
</pre>
</div>

<p>
<a href="./imagens/cgi_lisp.png">./imagens/cgi<sub>lisp.png</sub></a>
</p>

<p>
Citei duas linguagem, mas qualquer liguagem podem ser usadas com CGI script.
</p>
</div>
</div>
</div>

<div id="outline-container-org7b0328a" class="outline-3">
<h3 id="org7b0328a"><span class="section-number-3">1.12</span> Extra: HTML e JavaScript</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Nesta documentação todos os processo foram efeito utiliza-se de programa para montar back-end interface, mas caso queira montar programas para o front-end, é possivel trabalhamos com algumas library também, por exemplo <b>CL-WHO</b>, que é um gerador de html. Vejamos um exemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(ql:quickload :cl-who)

(cl-who:with-html-output (*standard-output* nil :prologue t)
  (:html (:body "Hello, World")) (values))

</pre>
</div>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><body>Exemplo</body></html>


<p>
Existem muitas possibilidades, caso queira visualizar melhor de uma olhada na página: <a href="https://edicl.github.io/cl-who/">https://edicl.github.io/cl-who/</a>. Também é possivel geramos código javascript de um código lisp usando o parenscipt, vejamos um exemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(parenscript:ps (defun greeting-callback() (alert "Hello, World")))
</pre>
</div>

<pre class="example" id="org26eb355">
"function greetingCallback() {
    __PS_MV_REG = [];
    return alert('Hello, World');
};"
</pre>

<p>
Para mais detalhes visualize a página: <a href="https://parenscript.common-lisp.dev/reference.html">https://parenscript.common-lisp.dev/reference.html</a>.
</p>
</div>
</div>
</div>



<div id="outline-container-org63ce732" class="outline-2">
<h2 id="org63ce732"><span class="section-number-2">2</span> Docker</h2>
<div class="outline-text-2" id="text-2">
<p>
Sistema docker é um sistema de maquinas virtualizadas, aonde cada maquina podem ser configurando conforme desejamos. O interessante neste sistema é cada aplicação podem além de possuirem um ambiente proprio, e graça a isto ele podem ser facilmente replicados. Ou seja, caso tenhamos que fazer um upscale da nossa aplicação não necessáriamente precisamos fazer um upgrade no hardware da nossa maquina, podemos simplimente duplicar nossa aplicação em outro conteiner, mas o mais interessante desse método é, como simplimente duplicamos nossa aplicação, caso ele não seja mais necessário podemos simplimente remover (matar) a nova maquina e retorna para a configuração de apenas um maquina. Obs.: eu disse duplica, mas não se limita em apenas duplica, como podemos multiplica por n vezes conforme é necessario.
</p>


<p>
Neste tutorial não vamos aborda o docker a fundo, irei aborta apenas o necessário para utilizamos o Cloun Run do Google Cloud. Então, a primeira coisa iremos precisar é saber como instalar o docker.
</p>
</div>
</div>


<div id="outline-container-org2298533" class="outline-2">
<h2 id="org2298533"><span class="section-number-2">3</span> Instalação</h2>
</div>


<div id="outline-container-org8281eff" class="outline-2">
<h2 id="org8281eff"><span class="section-number-2">4</span> Cloun Run (Google Cloud)</h2>
</div>

<div id="outline-container-orge21f162" class="outline-2">
<h2 id="orge21f162"><span class="section-number-2">5</span> <a href="https://hitokey.github.io/">Home</a></h2>
<div class="outline-text-2" id="text-5">
<p>
Minha Página (My Page): <a href="https://hitokey.github.io/">https://hitokey.github.io/</a>
</p>
</div>
</div>

<div id="outline-container-orgdb5786c" class="outline-2">
<h2 id="orgdb5786c"><span class="section-number-2">6</span> imagens/cgi<sub>lisp.png</sub></h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Data: 2022-03-24 Thu 00:00</p>
<p class="author">Autor: Pedro Fernandes</p>
<p class="date">Criado em: 2022-04-07 Thu 13:24</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
