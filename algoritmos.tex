% Created 2021-03-09 ter 07:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Pedro Fernandes}
\date{\textit{<2021-03-09 ter>}}
\title{Simples programa Fib}
\hypersetup{
 pdfauthor={Pedro Fernandes},
 pdftitle={Simples programa Fib},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={Pt_br}}
\begin{document}

\maketitle
\tableofcontents


\section{Introdução}
\label{sec:org22d779c}

Estou escrevendo este documento para testar o github blog, estão não espere nada demais nesta página.


\subsection{Fibonacci}
\label{sec:orgb8e291a}

Fibonacci é série numerica que descreve a seguinte senquencia \textbf{1,1,2,3,4,5,8,13\ldots{}}, dessa maneira Leonardo Pisa descreve o crescimento pela seguiente fórmula: \(F_n=F_{n-1}+F_{n-2}\), com a condição inicial f(0) = 0 e f(1) = 1, então:

$$ \big{{} {{0 se n = 0 \newline 1 se n = 1 \newline otherwise f_{n-1}+f_{n-2}}}$$


Agora descrevemos em common lisp. Obs.: eu implementei no elisp em um emacs-windows. 

\begin{verbatim}
(require 'cl)

(defun fib(n)
   (if (<= n 2) 1
	 (+ (fib (- n 1)) (fib (- n 2)) )))

(format "Fib(%d):= %d" 5 (fib 8))
\end{verbatim}

Eu quero verificar o tempo de execução da função fib que implementamos no elisp. 

\begin{verbatim}
(benchmark-run 1 (fib 40))
\end{verbatim}

É demorou 60 segundos para executar o fibonacci 40, na lista o primeiro é o tempo real de execução, segundo o número fde coletas de lixos e finalizando o tempo gasto pelo coletor de lixo, agora executar por meio de uma complexão binária.

\begin{verbatim}
(benchmark-run-compiled 1 (fib 40))
\end{verbatim}

Não mudou particamente nada, principalmente se adicionamos o erro experimental. 

Podemos mudar um pouco a nossa função fibonacci, porque na nossa função como usamos da recursão, o sistema deverá ultizar bastante a pinha para amazenar e depois recalcular o valor de resposta. Então irei implentar utilizando a recursão, mas adicionarei um acumulador.

\begin{verbatim}
(defun fib-acc(n prev acc)
  (if (<= n 0) acc 
     (fib-acc (- n 1) acc (+ prev acc))))

(defun fib(n)
  (if (<= n 1) n
    (fib-acc n 1 0)))

(funcall (lambda (n) (format "Fib(%d): %d" n (fib n))) 40)
\end{verbatim}

\begin{verbatim}
(benchmark-run-compiled 1 (fib 40))
\end{verbatim}

Notamos que o tempos foi de 1.5x10\(^{\text{5}}\), particamente zero, estão é bom trabalhamos com acumulador.
\end{document}
